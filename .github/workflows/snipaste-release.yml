name: Snipaste Auto Release

on:
  schedule:
    - cron: '0 0 * * *'  # 每天UTC时间0点运行
  workflow_dispatch:  # 允许手动触发

permissions:
  contents: write  # 确保内容写入权限

jobs:
  check-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up environment
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Get latest release version
        id: get_latest_release
        run: |
          response=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          if echo "$response" | jq -e '.tag_name' > /dev/null; then
            LATEST_RELEASE=$(echo "$response" | jq -r '.tag_name')
          else
            LATEST_RELEASE="0.0"
          fi
          echo "Latest release: $LATEST_RELEASE"
          echo "latest_release=$LATEST_RELEASE" >> $GITHUB_OUTPUT

      - name: Check for new version and download files
        id: check_version
        run: |
          declare -A urls=(
            ["win-x64"]="https://dl.snipaste.com/win-x64"
            ["win-x86"]="https://dl.snipaste.com/win-x86"
            ["mac"]="https://dl.snipaste.com/mac"
            ["linux"]="https://dl.snipaste.com/linux"
          )
          
          # 创建并进入文件目录，简化路径处理
          mkdir -p snipaste_files
          cd snipaste_files
          
          # 下载文件
          for platform in "${!urls[@]}"; do
            echo "Downloading $platform..."
            final_url="${urls[$platform]}"
            final_url=$(curl -sIL -o /dev/null -w "%{url_effective}" "$url")
            filename=$(basename "$final_url")
            
            # 下载文件并验证
            if ! curl -L -o "$filename" "$url"; then
              echo "Error: 下载 $platform 失败"
              exit 1
            fi
            if [ ! -s "$filename" ]; then
              echo "Error: 文件 $filename 为空或不存在"
              exit 1
            fi
            
            echo "Downloaded file: $filename"
            echo "$filename" >> ../file_list.txt
            
            # 提取版本号
            version=$(echo "$filename" | sed -E 's/^Snipaste-([0-9]+\.[0-9]+(\.[0-9]+)?).*$/\1/')
            if ! echo "$version" | grep -qE '^[0-9]+\.[0-9]+(\.[0-9]+)?$'; then
              echo "Error: 无法从文件名 $filename 提取版本号"
              exit 1
            fi
            echo "$version" >> ../version_list.txt
          done
          
          # 返回上级目录
          cd ..
          
          # 验证所有版本一致
          version_list=$(sort -u version_list.txt)
          version_count=$(echo "$version_list" | wc -l | tr -d '[:space:]')
          if [ "$version_count" -ne 1 ]; then
            echo "Error: 版本不一致 - $version_list"
            exit 1
          fi
          NEW_VERSION=$(echo "$version_list" | head -n 1 | tr -d '[:space:]')
          
          # 准备文件列表（使用相对路径）
          files_to_upload=$(cat file_list.txt | while read -r file; do echo "snipaste_files/$file"; done | tr '\n' ' ')
          
          # 调试信息 - 确认文件存在且路径正确
          echo "===== 最终文件列表及状态 ====="
          for file in $files_to_upload; do
            if [ -f "$file" ]; then
              echo "存在: $file (大小: $(du -h "$file" | cut -f1))"
            else
              echo "不存在: $file"
            fi
          done
          echo "=============================="
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "files_to_upload=$files_to_upload" >> $GITHUB_OUTPUT

      - name: Create release with assets
        if: steps.check_version.outputs.new_version != steps.get_latest_release.outputs.latest_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.check_version.outputs.new_version }}
          name: Snipaste ${{ steps.check_version.outputs.new_version }}
          body: |
            Auto-released version ${{ steps.check_version.outputs.new_version }}
            Contains builds for:
            - Windows x64
            - Windows x86
            - macOS
            - Linux
          # 明确列出每个文件，避免通配符问题
          files: ${{ steps.check_version.outputs.files_to_upload }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
